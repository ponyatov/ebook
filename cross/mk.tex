\secrel{Makefile}

Вся сборка проекта управляется через \file{Makefile}, поделенный на несколько
частей:

\lstinputlisting[style=mk,title=Makefile.mk,
linerange={1-1}]{cross/Makefile.mk}

\secdown

\input{cross/app}
\input{cross/hw}
\input{cross/packs}

\secru{Директории}

в которых будет производиться сборка, и формироваться целевая файловая система.

\secdown

\secrel{PWD}

Встроенная переменная, возвращает текущий каталог, из которого быз запущен
\file{make}, т.е. \file{/home/user/book/cross}.

\secrel{GZ}

Каталог для хранения архивов исходных текстов пакетов, закачанных из \internet\
(локальное зеркало). Если вы работаете сразу с несколькими проектами, создайте
отдельный каталог, например \file{/home/user/gz}, и из каждого проекта сделайте
на него симлинк \file{ln -s /home/user/gz gz}. В этом случае все архивы окажутся
общими для всех проектов, причем там могут лежать несколько версий одного
пакета.

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=32,linerange={32-32}]{cross/Makefile.mk}

\secrel{SRC}

Сюда будут распаковываться исходные тексты пакетов

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=33,linerange={33-33}]{cross/Makefile.mk}

\secrel{TMP}

Здесь будут создаваться и удаляться временные файлы и каталоги при сборке
пакетов\ --- out of tree сборка, за исключением пакетов, которые могут быть
собраны только в каталоге с исходными текстами.

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=34,linerange={34-34}]{cross/Makefile.mk}

\secrel{TC}

От ToolChain, или TargetCompiler\ --- сюда поместим собранный кросс-тулчейн,
чтобы не засорять основную \linux-систему, и иметь возможность пользоваться
разными версиями компиляторов для разных проектов

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=35,linerange={35-35}]{cross/Makefile.mk}

\secrel{ROOT}

В этом каталоге будем собирать \term{rootfs}\ --- корневую файловую систему

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=36,linerange={36-36}]{cross/Makefile.mk}

\secrel{BOOT}

В этот подкаталог поместим откомпилированное ядро, файлы загрузчика и другие
файлы, обеспечивающие запуск системы до момента монтирования rootfs.

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=37,linerange={37-37}]{cross/Makefile.mk}

\secup

\secru{Макросы команд}

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=39,linerange={39-42}]{cross/Makefile.mk}

\secru{\file{dirs}}

Создание дерева каталогов для сборки.
Каталоги не зачищаемые пакетом \file{distclean}, прописаны отдельно. 

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=44,linerange={44-47}]{cross/Makefile.mk}

\secru{\file{distclean}}

Зачистка проекта, применяется при полной пересборке

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=49,linerange={49-52}]{cross/Makefile.mk}

\secru{Загрузка архивов исходников\ --- \file{gz}}

Длительная и потребляющая трафик операция, нужен онлайн.
По-хорошему архив исходников тут было бы желательно загружать через пиринговые
сети, а не нагружать зеркала. Если эта книга вдруг окажется популярной, нужно
будет сделать хранение архивов на торрентах.

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=54,linerange={54-63}]{cross/Makefile.mk}

\secru{Шаблоны распаковки исходников}

Распаковка исходных текстов пакетов сделана через шаблоны:

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=65,linerange={65-70}]{cross/Makefile.mk}

Для каждого типа архива задано правило, по которому архив должен быть
распакован, \file{make}\ контролирует факт распаковки по наличию файла
\file{README}, и отслеживает дату модификации файла архива.

\secru{Конфигурирование пакета}

Конфигурирование почти всех пакетов на этапе сборки выполняется с помощью
скрипта \file{src/package-version/configure}, созданного разработчиком пакета с
использованием средств \term{autotools}/\term{automake}.

Этот скрипт при своем запуске выполняет общую диагностику BUILD-системы, на
которой собирается пакет, учитывая значения параметров, заданные в командной
строке при его запуске.

В результате в текущем каталоге, где был запущен \file{configure}, создается
набор файлов, обеспечивающих дальнейшую сборку пакета через \file{make}\ и
установку его готовых бинарных файлов через \file{make install}.

Если сборка пакета выполняется в отдельном временном каталоге типа
\file{tmp/package-version}, такая сборка называется \term{out-of-tree}\ сборка.

Некоторые пакеты требуют сборку \textbf{в каталоге с исходниками}
\file{src/package}, и сборка называется \term{in-tree}\ сборка.

Общая часть вызова команды \file{configure}\ задана в переменной 

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=72,linerange={72-72}]{cross/Makefile.mk}

\begin{itemize}
  \item \file{--diable-nls}\ отключает поддежку локализации (русского языка) в
  диагностическом выводе команд пакета
  
  Использование этого параметра немного ускоряет и упрощает процесс компиляции,
  и кроме того в IT\footnote{\ информационные технологии}-сфере разработчикам
  удобнее работать с диагностическим выводом компиляторов на английском, т.к.
  исчезают проблемы с кодировками между разными системами и выводом
  <<кракозябр>>. Также проще искать в \internet е подробную информацию об
  ошибках в программе.
  
  \emph{Не стоит забывать, что знание базового технического английского на
  уровне свободного чтения документации и диагностики\ --- один из минимально
  необходимых навыков IT-специалиста, наравне с умением пользоваться поисковыми
  системами типа Google. Если вы не можете это делать хотя бы со словарем,
  значит вы всего-лишь профнепрегодны для этой профессии.}
\end{itemize}

\secup
\secru{Сборка кросс-компилятора}
\secdown

При сборке \term{кросс-компилятора}\ используются две или три переменные,
содержащие \term{триплеты}\ указывающие на архитектуру каждой системы:

\begin{itemize}
  \item \file{BUILD}\ система, на которой производится сборка кросс-компилятора,
  например \file{i686-pc-linux-gnu} 
  \item \file{HOST}\ система, на котрой кросс-компилятор будет выполняться,
  например \file{i686-mingw32} (Windows без Cygwin-прослойки)
  \item \file{TARGET}\ целевая система, для которой компилируется ваш код,
  например \file{arm-none-eabi} (Raspberry Pi)
\end{itemize}

Соответствено для конфигурирования пакетов, которые будут работать либо на
билд-системе, либо компилироваться для целевой системы, нужно использовать
разные варианты запуска \file{configure}:

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=74,linerange={74-75}]{cross/Makefile.mk}

\begin{itemize}
  \item параметр \file{--prefix}\ задает каталог, в который будет помещен
  откомпилированный пакет
\end{itemize}

\secrel{binutils}

\lstinputlisting[style=mk,title=Makefile.mk,
firstnumber=77,linerange={77-83}]{cross/Makefile.mk}

Удаляется если существует, и создается новый каталог out-of-tree сборки
\file{tmp/binutils-version}, и в нем запускается скрипт \file{configure}
в варианте для билд-системы, дополненный параметрами для \file{binutils}:

\begin{itemize}
  \item \file{--target}\ указываем триплет для целевой системы, binutils будут
  собираться для ее системы команд, набора регистров, параметров оптимизации
  \item в \file{CFG\_CPU}\ заданы параметры конкретного целевого процессора, см.
   файлы \file{hw/$<$system$>$.mk}, \file{cpu/$<$cpu$>$.mk}. Эти параметры будут
   жестко прописаны в настройки оптимизации и код кодогенерации binutils, и вы сможете
   скомпилировать вашу программу только конкретно для этого процессора, или
   полностью совместимого с ним на уровне машинного кода.
\end{itemize}

После отработки \file{configure}\ сразу запуститься сборка пакета (\file{make}),
и если не будет ошибок (это контролирует разделитель \verb|&&|), скрипты
инсталляции.

В результате в (ранее пустом) каталоге \file{\$(TC)=/home/user/book/cross/tc}\ 
появится дерево файлов откомпилированного \file{binutils}:

\begin{itemize}
  \item \file{bin/\$(TARGET)-as} \term{ассемблер}\ для целевой платформы
  \item \file{bin/\$(TARGET)-ld} \term{линкер}
  \item \file{bin/\$(TARGET)-objcopy} \term{копировщик секций} объектного кода
  (\file{.o}-файлы в формате ELF)
  \item \file{bin/\$(TARGET)-objdump} \term{дампер}\ позволяющий вывести как
  шестнадцатеричный дамп, дизассемблированный код для секций файлов
  .o (ELF). \emph{Эта же пограмма используется для получения бинарных и
  \file{.hex}\ файлов прошивок для микроконтроллеров}
  \item \file{bin/\$(TARGET)-size} программа выводит размеры секций .o
  \item \file{bin/\$(TARGET)-strip} \term{стриппер}\ удаляет отладочную
  информацию из объектных и исполняемых файлов\footnote{\ для \linux\ отличий в
  формате нет}
  \item \file{share/} документация в форматах man и info
\end{itemize}

На этом этапе вы уже можете пользоваться \file{кросс-ассемлером}\ для целевой
системы, компилируя их в файлы \term{объектного кода}, c помощью линкера
соединять несколько объектных файлов и файлов сторонних библиотек в один
исполняемый, уже содержащий полностью готовую к исполнению программу в машинном
коде целевой системы.

\secru{Сборка кросс-асемблера для AVR8 (Arduino/\ldots)}

Если вы пользуетесь этим руководством, с большой долей вероятности вам
потребуется подключать к вашей встраиваемой системе внешние контроллеры
ввода/вывода на базе микроконтроллеров Atmel AVR8 или Cortex-M.

В этом случае можно выполнить пару команд, собрав кросс-ассемблер для ходовых
микроконтроллеров, выполняющийся на host-системе:

\begin{lstlisting}[title=binutils-avr8]
user@builder:/home/user/cross$> make HW=avr8 CPU=atmega8 binutils
\end{lstlisting}

\emph{В этом примере показано, как вручную жестко переопределить значения
переменных в Makefile, изменяя его логику работы. В частности, мы собираем
\file{binutils}\ для другой платормы, причем переопределяем еще и тип
процессора.}

\secru{Сборка кросс-\file{binutils}\ для \cm{x}}

Аналогично можно собрать пакет кросс-\file{binutils}\ для микроконтроллеров
STM32 \cm{0\ldots 4}:

\begin{lstlisting}[title=\cm{x}]
user@builder$> make HW=STM32VLDISCOVERY binutils
\end{lstlisting}

\lstinputlisting[style=mk,title=cpu/arm/STM32F103RB.mk]{cross/cpu/arm/STM32F103RB.mk}
\lstinputlisting[style=mk,title=cpu/arm/CortexM3.mk]{cross/cpu/arm/CortexM3.mk}

\secup
